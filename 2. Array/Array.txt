○ 배열이란?

 1. 같은 type의 데이터를 집합구조로 만든 타입
 2. 메모리(내부)에 물리적으로 연속된 공간에 할당되고 연산속도를 증가시키기 위해 사용

 - Homogeneous Collection (동형 집합 구조)

  ----------------------
  |  |  |  |  |  |  |  | -> memory size가 동일한 구조가 연속되어 할당
  ----------------------



○ 배열을 사용하는 이유

 - usecase를 찾아보고 생각해볼것.
 1. 네트워크 전송시에 직렬화 하여 배열 형태로 전송한다.  (왜? 찾아봐)
 

** 배열과 링크드리스트 가은 자료구조를 언제 사용해야 하는지 꼭 생각하고 사용할 것.
 class 프로젝트 할 때 read only이고 데이터가 추가되는 것도 아니고 각각의 메모리가 동일한 형태인데 
 링크드리스트를 사용할 필요가 있었는가?



○ 배열의 자바 문법

   int[] ary = new int[3];
   -> 할당 후 constructor(생성자)를 호출하여 초기값(0)으로 초기화한다.

   ** 자바는 Data Loading시 new 연산자로 동적할당을 하는데,
      할당을 하고 나면 반드시 constructor가 호출이 되어 default 값인 0으로 초기화한다.
      -> new allocator는 할당을 하고나면 자동으로 생성자를 호출한다.

   ** 로컬변수에서 배열을 선언할 떄, int[] arr; 이라고 선언만 하고 초기화를 해주지 않으면
      System.out.println(arr); 이라고 출력할 때 Compile Error가 발생한다.
      그러므로 값을 초기화하지 않는다면 int[] arr = null; 이렇게 초기화를 해줘야한다.




○ 실행코드 시 차이

  1. main() 에서 실행시 -> 로컬변수로 선언될 떄

  int[] arr = new int[3];

    |      stack     |      heap      |
  ------------------------------------|
    |                |                |
    |                |  1000          |     처음에 arr이 생성되면서 null로 초기화가 되었다가
    |     ------     |  ------------- |     new 연산자가 heap 영역에 메모리를 할당하고 생성자 호출을 하게 된다.
    | arr| 1000 |    |  | 0 | 0 | 0 | |     생성자 호출이 되면서 0으로 초기화가 된다.
    |     ------     |  ------------- |     
    |                |                |     그림에는 1000번지라고 적혀 있지만 실제로는 1000번지의 주소를 찾을 수 있는 참조값을 가지고 있다. 
  --|----------------|----------------|     그 참조값을 JVM이 연산하여 1000번지를 찾아가는 것이다.
                                            - JVM이 주소를 연산하는데, JVM은 OS 마다 다르기 때문에 OS마다 주소계산 방법이 모두 다르다.


  2. class의 멤버변수일때

  A obj = new A();

    |      stack     |      heap      						           |
  -----------------------------------------------------------|
    |                |             						               |   class의 멤버변수 일 경우에는 A 클래스의 변수인 obj가 stack영역에 할당되고
    |                |  2000          						           |   실제 A 객체는 heap영역에 할당된다.
    |     ------     |  ------------------------------------ |   그래서 A 객체가 할당된 공간 안에 arr이 그림과 같이 할당된다.
    | obj| 2000 |    |  |       -----     3000             | |     
    |     ------     |  |  arr | 3000| -> -------------    | |   단, 이렇게 생성되려면 A의 생성자 안에 arr = new int[3]; 부분이 있어야 한다.
    |                |  |       -----     | 0 | 0 | 0 |    | |   arr을 할당하는 부분이 없으면 arr은 null값을 가지고 있고 3000번지는 할당되지 않는다.
    |                |  |                 -------------	   | |
    |                |  ------------------------------------ |     
    |                |                						           |     
  --|----------------|---------------------------------------|     




○ 배열 초기화

  - int[] arr = {1, 2, 3};
    -> 이렇게 선언과 동시에 초기화를 하면 new 연산자가 내부적으로 자동호출된다.
  
  - arr = {3, 4};    Error
    -> 이렇게 사용하면 new 연산자가 호출이 되지 않으므로 Error가 난다.

  - arr = new int[] {30, 40};
    -> 다시 초기화 하고 싶으면 이렇게 써도 되지만, 이렇게 하면 앞에 할당된 {1, 2, 3}은 쓰레기 객체가 된다.


○ 배열의 항목 수 알아내는 법

  arr.length 를 이용하여 배열의 크기를 알 수 있다.

  * 특별히 length 멤버변수는 private이 아니라 final로 선언되어 있어서 직접접근은 가능하지만 값을 변경할 수는 없다.


















