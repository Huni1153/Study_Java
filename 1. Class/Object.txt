● 객체 (Object)

● 객체지향 (Object Oriented == Organized) : 객체로 조직화(조직된) 하기위한 개념 [추상화, 캡슐화, 상속, 다형성]
                                                    --> 각각 역할분담(각자의 하는일에 따라 분리한다.)  


○ 객체란?
	
    - 오감을 느낄수 있는 모든것은 객체를 생성할 수 있다. -> 모든것을 프로그래밍 할 수 있다.
    --> 객체를 만드려고 할 때는 그 단어의 일반적인 속성(일반화)를 떠올릴 것이 아니라, 
        ** 어떤 관점에서(어떤 해결관점)에서 ** 그 객체를 볼것인지를 가장 먼저 정해야 한다.
        어떤 관점이냐에 따라서 그 객체를 구성하는것이 달라진다.
        같은 물체를 객체화 할 때, 그 객체가 필요한 상황에 따라 객체를 구성하는 성분이 달라질 수 있기 때문이다.


○ 객체를 설계하는 규칙(개념)

    - 추상화, 캡슐화
      -> 클래스 1개를 설계할 때 적용하는 개념.

    - 상속, 다형성
      -> 클래스 n개의 관계를 정의하는 개념(->조직화)


** OOP적 관점에서 가장 중요한 것은 여러사람의 의견을 모아서 여러사람이 가능한 모두 만족할 수 있는 제 3의 아이디어를 뽑아내는 것이다.
--> 가장 최상위는 일반화가 된(어떤 요구사항이라도 모두 해결할 수 있는) Class
--> 그래서 OOP적 관점에서 클래스를 설계할 때에는 최대한 모든 경우의 수를 생각해서 설계를 하는 것이 맞다.


---------------------------------------------------------------------------------------------------------------

○ 객체(Object)란? : Data를 캡슐화 한 것이다.
    ↓
  캡슐화한 Data를 우리는 Member 변수라고 부른다.
    ↓
  캡슐화한 데이터는 항상 Information hiding 기법을 적용한다.

   ·사람으로 치자면 사람의 캡슐화한 데이터는 재산!
                                           ↓
                                      재산은 숨겨야 되는것.


    - Class object : Logical object(논리 객체) ( + schema(인스턴스의 스키마) or blueprint for instance(청사진))
                     --> 프로그램이 구동되기 전에 논리객체의 schema 정보가 heap 영역에 저장되어 있고,
                        그 정보를 가지고 물리객체를 생성하는 것이다.

    - Instance object : physical object(물리 객체)
                       --> 실행 프로그램 구동 + 인스턴스화 구문(객체 생성). 실행상대
                                             -> Memory 로딩상태 -> 인스턴스화 구문하면 new allocator!
            ·클래스 명명규칙
            ┌───────────┐                                                              ┌───────────┐
            │           │ ────→ Pascal Casing                         ┌─────┐     ㅁ   │"나는 낙타" │
            ├───────────┤       (클래스, 생성자)                       │   ● │          └───────────┘
            │           │ ┐	                                          └───┯ │  ┌───┐  ↙
            ├───────────┤ ├───→ Camel Casing                              │ │  │   │
            │           │ ┘      (멤버 요소)       ㅁㅁㅁㅁㅁㅁㅁ           │ └──┘   └───
            └───────────┘                                                 │            =   
                                                                          │  ┌───────┤ 
                                                                          │  │       │ 
                                                                          ┗──┘       ┗─ 
● 캡슐화

    - 키추출을 통해 멤버변수와 메소드를 지정하고, 변수의 접근제어자를 private으로 해서 data hiding을 하고 그 변수에 접근할 수 있는 메소드를 정의하고 
      객체를 생성할 때 가능한 의미있는 데이터로 생성하자! 라는 룰에 따라 생성자 오버로딩 메소드들을 만드는것!

                                                                            
○ 추상화

    ① 유즈케이스 정의서의 키추출을 통해 기초 클래스를 설계하는 것.
    ② 여러 클래스들의 공통점을 뽑아서 상위클래스(Super class)를 만드는 것.
    ③ 캡슐화한 클래스의 데이터중 일부는 숨기고 일부는 공개하는 것.

   

                       ┏ class → 인스턴스(실제 클래스 객체)
   · 객체 → data 캡슐화 ┃
                       ┗ 설계도 → 클래스 다이어그램


   (문제 해결 관점)            필요한 데이터도 추출하지만 고유의 식별번호가 필요할 것 같으면 식별방법도 고안할 것.
   		 ∥                                                                 ↖
     시스템 한계                                                        유즈케이스 정의서	
     	 ∥                                                          (필요한 데이터를 찾아내는 것)
   추상화 전제조건 → 캡슐화할 data를 추출 ┐
                   (후보추출)           │
                    class의 멤버,함수   ┘
									   